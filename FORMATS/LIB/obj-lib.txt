Linker Overview
                              Linker Overview

-  The primary purpose of a linker is to produce an file which can be
   executed by an operating system.

-  In DOS, executable files come in three flavors:

                          "EXE" files
                          "COM" files
                          "SYS" files

-  The input to the linker comes from module(s) called translator
   modules.

-  Individual translator modules can be stored in "OBJ" files.  "OBJ"
   files are produce by language translators such as assemblers and
   compilers.

-  Libraries of translator modules can be stored in "LIB" files which
   are produced by a librarian from either "OBJ" files or other "LIB"
   files.

-  A linker can process translator modules from either "OBJ" or "LIB"
   files, but at least one module must have come from an "OBJ" file.

-  All translator modules from "OBJ" files will be included in the
   executable file, but only modules which resolve externals come from
   "LIB" files.


                    Comparison of Executable Files

-  "EXE" files have a header which contains relocation and other
   information which permit "EXE" files to have multiple segments.
   This header sets "EXE" files apart from the other executable file
   types.  Programs are written starting at address 0 (relative to
   where the program is loaded in memory).

-  "COM" files have no header.  "COM" files are written starting a
   address 100H because the "COM" file is loaded immediately after the
   program segment prefix (PSP) which is 100H bytes long.  At the start
   of the program, the CS and DS segment registers point to the PSP.
   "EXE" files which have an empty relocation table can be converted to
   "COM" files by the "EXE2BIN" program.

-  "SYS" files are more closely related to "COM" files than "EXE"
   files.  "SYS" files are loaded once at DOS initialization time.
   Since there is no PSP, the programs are written starting at address
   0.  However, like "COM" files, "SYS" files must have an empty
   relocation table.



                         Contents of Executable Files


    "EXE" files                                      "SYS" files
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                                ÚÄÄÄÄÄÄÄÄÄÄÄ¿
³   "EXE" header   ³                                ³load moduleÃÄÄ¿
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                                ÀÄÄÄÄÄÄÄÄÄÄÄÙ  ³
³ relocation table ³                                               ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                    ÚÄÄÄÄÄ¿                    ³
³   load module    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´org 0ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                    ÀÄÄÄÄÄÙ



                        "COM" files
                       ÚÄÄÄÄÄÄÄÄÄÄÄ¿                 ÚÄÄÄÄÄÄÄÄ¿
                       ³load moduleÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´org 100H³
                       ÀÄÄÄÄÄÄÄÄÄÄÄÙ                 ÀÄÄÄÄÄÄÄÄÙ


-  Each of the above contents are described in detail in the following
   slides.


                              "EXE" File Header
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Offset³                       Description                             ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³00-01 ³ The "EXE" file signature 4D5AH.                               ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³02-03 ³ Length of the "EXE" file modulo 512.                          ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³04-05 ³ Number of 512-byte pages.  If the last page is not full it is ³
³      ³ still included in the count.                                  ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³06-07 ³ Number of relocation items.                                   ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³08-09 ³ Num of 16-byte paras occupied by "EXE" header and relo table. ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0A-0B ³ Number of paragraphs required immediately after load module.  ³
³      ³ The linker computes the number of uninitialized bytes at the  ³
³      ³ end of the load module.  Instead of writing these bytes to    ³
³      ³ the "EXE" file, the linker sets this value to provide space   ³
³      ³ for this data.                                                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0C-0D ³ Max number of paras which may be required immediately after   ³
³      ³ the "EXE" file. This value comes from the CPARMAXALLOC switch.³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0E-11 ³ Offset/Segment displacement into the load module of initial   ³
³      ³ SP/SS/. The displacement is converted to an actual address by ³
³      ³ adding the base address of the load module.  Since there may  ³
³      ³ be several stack segments in the translator modules, the      ³
³      ³ linker uses the highest address of the largest segment with   ³
³      ³ the stack attribute.                                          ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³12-13 ³ Word checksum computed as minus the sum of all the words in   ³
³      ³ the file.  Overflows are ignored.  DOS will not validate the  ³
³      ³ checksum if this value is set to zero                         ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³14-17 ³ Offset/Segment displacement into the load module of the       ³
³      ³ initial IP/CS.  The displacement is converted to an actual    ³
³      ³ address by adding the base address of the load module.        ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³18-19 ³ Lgh of "EXE" file header. (Used to find start of relo table.) ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1A-1B ³ Overlay number.  This is zero for the main program.           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1C-1D ³ Always 0001H.                                                 ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Note:  "EXE" file header routines are in "EXECFILE.C" (handout page 9)


                               Relocation Table

The number of relocation items is specified at offset 06-07 in the
"EXE" file header.  The offset of the relocation table is located at
offset 18-19 in the "EXE" file header.  Usually this value is 001EH,
but can be larger if the "EXE" file header has been extended.

The relocation table can be viewed as an array of Offset/Segment
displacements into the load module.  For each address, the segment
portion of the base address of the load module is added to the word at
that displacement.  The only time a relocation item is needed is when a
fixup involves a segment.  As we will see later, this can only be
caused by base and pointer type fixups.

As an example of a how a relocation item is generated, consider the
following:

                           foo      db      'a'
                           bar      dd      foo

Note that the contents of "bar" is the address of "foo", but the actual
address of "foo" is not known until the program is loaded in memory.
All that is known at link time is how far (i.e., the displacement) into
the load module "foo" and "bar" are located.  Only the displacement of
"foo" is stored at link time.  But, the linker makes a relocation entry
showing that "bar"+2 must be relocated.



                             Load Module

By far, the generation of the load module is the trickest part of
producing an executable file.  The contents of the load module is
generated from the contents of translator modules stored in "OBJ" and
"LIB" files.  Much of the structure of translator modules comes from
the assembler directives.  In turn, those directives are related to the
architecture of the 80x86 family of micros.

Here are some of the important directives:

SEGMENT/ENDS is used to give a logical name along with grouping and
     combining information for the segments.  The linker is responsible
     for arranging and combining these logical segments into the
     physical segments which comprise a load module.

EXTRN/PUBLIC is used access data across translator modules.

A detailed description of the format of translator modules follows.


                      Terminology and Abbreviations

MAS - Memory Address Space:  The memory capable of being addressed by
    the hardware architecture.

T-MODULE - Translator Module:  This is a unit of object code produced
    by a language translator.  They may be stored individually in "OBJ"
    files or collections may be stored in "LIB" files.

FRAME:  A contiguous 64K chunk of MAS.

FRAME NUMBER:  Paragraph number where a FRAME begins.

CANONIC FRAME:  For the 8086, each byte of memory is encompassed by up
    to 4096 FRAMEs.  The CANONIC FRAME frame is lowest FRAME NUMBER
    which encompasses that byte.

LSEG - Logical Segment:  Data and code between SEGMENT - ENDS
    directives.

PSEG - Physical Segment:  A collection of one or more LSEGs placed into
    a load module.



                            Fixup Overview

Not all references to MAS can be resolved at translation time.  This
can happen when one T-MODULE must access data located in another
T-MODULE.  When this happens, the language translator places an entry
in the T-MODULE so that the linker can complete the address reference.
Such entries in a T-MODULE are called "Fixups".

In order for the linker to complete the address reference, it needs
five pieces of information:

          The LOCATION in memory where the reference occurs.  This is
        the address which must be fixed up.

          The type of LOCATION in memory where the reference occurs.

          Whether the fixup is relative to the IP or not.  This is
        refered to as the fixup MODE.

          The TARGET address which LOCATION is referencing.

          The FRAME number in the segment register used to reference
        the TARGET address.


                            LOCATION Types

There are five types of LOCATIONs.  They are POINTER, BASE, OFFSET,
HIBYTE, and LOBYTE.  The relative position and length of each LOCATION
type from a LOCATION, X is given below:

             ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
             ³   X+0    ³   X+1    ³   X+2    ³   X+3    ³
             ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ

             ÃÄÄLOBYTEÄÄ´

                        ÃÄÄHIBYTEÄÄ´

             ÃÄÄÄÄÄÄÄOFFSETÄÄÄÄÄÄÄÄ´

                                   ÃÄÄÄÄÄÄÄÄBASEÄÄÄÄÄÄÄÄÄ´

             ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPOINTERÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´


                             Fixup Modes

There are two fixup modes.  Both modes stem from the architecture of
the 80x86 microprocessor family.  The TARGET may be addressed directly
via the offset/segment mechanism.  This fixup mode is called
"segment-relative".

The other manner a TARGET may be addressed is relative to the IP.  For
example, the TARGET of the 80x86 jump instructions (e.g., JE, JC, JA,
etc) are all relative to the IP.  This fixup mode is called
"self-relative".  Note that the self-relative mode is relative to the
value of the IP when the instruction executes.  In all cases, the IP
points to the first byte of the instruction following the one being
executed.


                                TARGET

The TARGET is the location in MAS being referenced by LOCATION.  There
are four basic ways of specifying the TARGET.  The four methods of
specifying a TARGET are:

                  TARGET is specified relative to an LSEG.
                  TARGET is specified relative to a group.
                  TARGET is specified relative to an external symbol.
                  TARGET is specified relative to an absolute FRAME.

The four primary methods specify a displacement while the four
secondary methods do not specify a displacement (because the
displacement is 0).

                            Primary TARGET Methods
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³       Notation          ³           Description               ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T0  ³SI(segment),displacement ³The TARGET is at the specified       ³
³      ³                         ³displacement in the LSEG segment.    ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T1  ³GI(group),displacement   ³The TARGET is at the specified       ³
³      ³                         ³displacement in the group.           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T2  ³EI(external),displacement³The TARGET is at the specified       ³
³      ³                         ³displacement past the external.      ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  T3  ³FR(frame),displacement   ³The TARGET is at the specified       ³
³      ³                         ³displacement past FRAME NUMBER frame.³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Example:

SI(foo),4 means the TARGET is 4 bytes into the LSEG foo.  Several
T-MODULES could have an LSEG named foo which may be combined into a
PSEG foo.  So, the final displacement in the PSEG foo may not be 4.
The linker must take this into consideration.

                           Secondary TARGET Methods

     ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³Method³ Notation   ³               Description                   ³
     ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³  T4  ³SI(segment) ³The TARGET is the base of the LSEG segment.  ³
     ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³  T5  ³GI(group)   ³The TARGET is the base of the group.         ³
     ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³  T6  ³EI(external)³The TARGET is the specified external.        ³
     ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³  T7  ³FR(frame)   ³The TARGET is the specified frame.           ³
     ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                                  FRAME
 
The FRAME portion of a fixup specifies the FRAME NUMBER that will be
used as the frame of reference for LOCATION's reference to TARGET.
Typically, this frame of reference is one of the segment registers.
The FRAME NUMBER in the segment register is specified via the assembler
"ASSUME" directive.

Even if the fixup is self-relative, the TARGET must still be in the
FRAME given by the FRAME NUMBER in the segment register.  So, a FRAME
is required for both segment-relative fixups and self-relative fixups.

There are seven methods of specifying a FRAME:

                             A segment
                             A group
                             An external
                             An absolute FRAME NUMBER
                             LOCATION's FRAME
                             TARGET's FRAME
                             No FRAME specified


                              FRAME Methods
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³                      Description                              ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F0  ³The FRAME for the fixup is the CANONIC FRAME of the PSEG       ³
³      ³containing the LSEG.  (Since the fixup is generated at         ³
³      ³translation time, an LSEG is specified.)                       ³
³      ³Notation:  EI(segment)                                         ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F1  ³The FRAME for the fixup is the CANONIC FRAME of the PSEG       ³
³      ³located lowes in MAS.  A group is specified.                   ³
³      ³Notation:  GI(group)                                           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F2  ³The FRAME for the fixup is specified by an external.           ³
³      ³Typically, the external is located in a T-MODULE different     ³
³      ³from the T-MODULE generating the fixup.                        ³
³      ³Notation:  EI(external)                                        ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F3  ³The absolute FRAME number is specified.                        ³
³      ³Notation:  FR(FRAME)                                           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F4  ³The FRAME is the CANONIC FRAME of the PSEG containing LOCATION.³
³      ³Notation:  LOCATION                                            ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5  ³The FRAME is determined by the TARGET.  Notation:  TARGET      ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F6  ³No frame of reference specified.  Notation:  NONE              ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                          FRAME Method F2 cases

When FRAME method F2 is specified (FRAME is specified by an external),
there are three cases depending on how the external is defined:

ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³                       Description                             ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F2a ³If the external is defined relative to an LSEG which is not in ³
³      ³a group then the FRAME is the CANONIC FRAME of the PSEG        ³
³      ³containing the LSEG.                                           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F2b ³If the external is defined absolutely and not in a group, then ³
³      ³the FRAME is the CANONIC FRAME of the external.                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³  F2c ³If the external is associated with a group, the FRAME is the   ³
³      ³CANONIC FRAME of the PSEG in the group with the lowest MAS.    ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                          FRAME Method F5 cases

When FRAME method F2 is specified (FRAME is specified by the TARGET),
there are four cases depending on how the TARGET was specified:

ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Method³                          Description                          ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5a ³If the TARGET method is T0 or T4, then FRAME is the CANONIC    ³
³      ³FRAME of PSEG containing TARGET.                               ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5b ³If the TARGET method is T1 or T5, then FRAME is the CANONIC    ³
³      ³FRAME of PSEG in the same group as TARGET and with the lowest  ³
³      ³MAS.                                                           ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5c ³If the TARGET method is T2 or T6, then the FRAME is determined ³
³      ³by the rules given in FRAME method F2.                         ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³  F5d ³If the TARGET method is T3 or T7, then the FRAME is the FRAME  ³
³      ³NUMBER specified by the TARGET.                                ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

                           Performing a Fixup

Regardless of the fixup mode (segment-relative or self-relative), the
first step in performing a fixup is to insure that the TARGET is
addressable given the FRAME of reference.  That is, the TARGET must lie
between FRAME and FRAME+65535 inclusive.

                      FRAME ó TARGET ó FRAME+65535

If this is not the case, a warning is given.

After verifying that TARGET can be addressed by FRAME, how a fixup is
performed depends of the FIXUP mode.


                          Self-Relative Fixups

Self-relative fixups are permitted for LOBYTE and OFFSET type LOCATIONs
only.  If the LOCATION type is HIBYTE, BASE, or POINTER, no fixup is
performed and an error message is given.

For self-relative fixups, the value of the PC (CS:IP) when the
instruction is executed must be determined.  Then, the DISTANCE to the
TARGET from the PC is computed.  The formulae for DISTANCE and PC are
given below:

                 PC = LOCATION + 1 (If LOCATION type is LOBYTE)
                 PC = LOCATION + 2 (If LOCATION type is OFFSET)
                 DISTANCE = TARGET - PC

For LOBYTE locations, an error is issued when DISTANCE falls outside of
-128 ó DISTANCE ó 127.

The fixup is performed by adding DISTANCE to LOCATION.  For LOBYTE
LOCATIONs, DISTANCE is added modulo 256.  For OFFSET LOCATIONs,
DISTANCE is added modulo 65536.

                         Segment-Relative Fixups

For segment-relative fixups, DISTANCE = TARGET - FRAME.  If DISTANCE
falls outside of 0 ó DISTANCE ó 65535, a warning is issued.  The
following table gives how to perform the fixup depending on LOCATION
type:
ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³LOCATION³                            Action                           ³
³  type  ³                                                             ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³LOBYTE  ³DISTANCE is added (modulo 256) to low order byte at LOCATION.³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³HIBYTE  ³DISTANCE is added (modulo 256) to high order byte at LOCATION³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³OFFSET  ³DISTANCE is added (modulo 65536) to the word at LOCATION.    ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³BASE    ³FRAME is added (modulo 65536) to the word at LOCATION.       ³
ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³POINTER ³DISTANCE is added (modulo 65536) low order word at LOCATION. ³
³        ³A relocation item for the word at LOCATION is created.       ³
³        ³FRAME is added (modulo 65536) to the high order word of the  ³
³        ³DWORD at LOCATION.  A relocation item for the high order word³
³        ³of the DWORD at LOCATION is created.                         ³
ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                      T-MODULE Record Format Basics

All T-MODULE records have the following basic format:

                       ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                       ³Record³ Record³Information Specific³Check³
  Field NamesÄÄÄÄÄÄÄÄÄ>³ Type ³ Length³   to Record Type   ³ Sum ³
                       ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
  Field LengthsÄÄÄÄÄÄÄ>³  1   ³   2   ³  Record Length - 1 ³  1  ³
     (bytes)           ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Record Type --
  This one byte field identifies the type of T-MODULE record.

Record Length -- 
  This word contains the number of bytes in all following fields
  (including the checksum).

Information Specific to Record Type --
  This field contains the data for the specified Record Type.
 
Check Sum --
  This byte contains the negative of the sum of all the preceding bytes
  in the record.  Therefore, the sum of all the bytes in the record
  will be 0.


                  T-MODULE Record Format -- Bit Fields

Bit fields are denoted as follows:

                               ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                               ³ Bit ³ Bit ³ Bit ³
        Field NameÄÄÄÄÄÄÄÄÄÄÄÄ>³Field³Field³Field³
                               ³  1  ³  2  ³  n  ³
                               ÃÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
        Field LengthÄÄÄÄÄÄÄÄÄÄ>³  4  ³  1  ³  3  ³
           (bits)              ÃÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄ´
                               ³      byte       ³
                               ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                     T-MODULE Record Format -- INDEX Fields

There are three special kinds of fields in a T-MODULE record:

"INDEX" fields:        ÚÄÄÄÄÄ¿
                       ³INDEX³
                       ÃÄÄÄÄÄ´
                       ³ 1-2 ³
                       ÀÄÄÄÄÄÙ

An INDEX field is one or two bytes long.  If the high order bit of the
first byte of the INDEX is 0, then the INDEX is one byte long and the
value is the remaining 7 bits (0 - 127).  Otherwise, the INDEX is two
bytes long and the value of the INDEX is the low order 7 bits of the
first byte * 256 plus the second byte.


                  T-MODULE Record Format -- NAME Fields

The format of a "NAME" field is:
                              ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿
                              ³ NAME ³   NAME    ³
                              ³Length³           ³
                              ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄ´
                              ³  1   ³NAME Length³
                              ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÙ

Note:  NAMEs of 0 bytes are permitted.  The NAME is not NULL
terminated.


                 T-MODULE Record Format -- VALUE Fields

The format of "VALUE" fields is:
                               ÚÄÄÄÄÂÄÄÄÄÄÄ¿
                               ³Code³Number³
                               ÃÄÄÄÄÅÄÄÄÄÄÄ´
                               ³ 1  ³ 0-4  ³
                               ÀÄÄÄÄÁÄÄÄÄÄÄÙ

When 0 ó Code ó 128, the Number field is omitted and the VALUE is Code.

When Code = 129, the Number field is 2 bytes long, and the VALUE is
Number.

When Code = 132, the Number field is 3 bytes long, and the VALUE is
Number.

When Code = 136, the Number field is 4 bytes long, and the VALUE is
Number.


                T-MODULE Record Format -- T-MODULE Header

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³T-MODULE NAME³Check³
                        ³80H³Length³             ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    NAME     ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

This record type must be the first record in the T-MODULE, and it names
the T-MODULE.  Frequently, the T-MODULE NAME is the name of the source
file to the language translator.


            T-MODULE Record Format -- List of NAMEs (LNAMEs)
                  
                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³            ³Check³
                        ³96H³Length³Logical NAME³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    NAME    ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄÄrepeatedÄÄÙ

Each Logical NAME is entered into a "List of NAMES" (LNAME) in the
order they are encountered in type 96H records.  The list index starts
at 1 (0 means not specified).  There may be more than one type 96H
record in a T-MODULE.  When this occurs, append the Logical NAMEs to
the list.  The Logical NAME field is repeated.  The number of
repetitions is determined by the Record Length.


           T-MODULE Record Format -- LSEG Definition (SEGDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³ Segment ³Segment³Segment³Class³Overlay³Check³
           ³90H³Length³Attribute³Length ³ INDEX ³INDEX³ INDEX ³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³  1-4    ³  2    ³ INDEX ³INDEX³ INDEX ³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Segment Attribute:  ÚÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿  ACBP:  ÚÄÂÄÂÄÂÄ¿
                    ³ACBP³FRAME NUMBER³Offset³         ³A³C³B³P³
                    ÃÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´         ÃÄÅÄÅÄÅÄ´
                    ³ 1  ³     2      ³  1   ³         ³3³3³1³1³
                    ÀÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄ´         ÃÄÁÄÁÄÁÄ´
                         ÀÄÄÄÄconditionalÄÄÄÄÙ         ³  Byte ³
                                                       ÀÄÄÄÄÄÄÄÙ
                                                Note:  ACBP.P must be 0.

There is one SEGDEF record for each LSEG in a T-MODULE.  Like the LNAME
list, this forms a list of LSEGs (indexed from 1).


                 T-MODULE Record Format -- SEGDEF.ACBP.A

The following table gives the meaning of the A field of the ACBP field:

ÚÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³A³                             Description                            ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0³This is an absolute segment.  The FRAME NUMBER and Offset fields of ³
³ ³the Segment Attribute field will be present.                        ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1³This is a relocatable, byte-aligned LSEG.                           ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³2³This is a relocatable, word-aligned LSEG.                           ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³2³This is a relocatable, paragraph-aligned LSEG.                      ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³4³This is a relocatable, page-aligned LSEG.                           ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³5³This is a relocatable, DWORD-aligned LSEG.                          ³
ÀÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                     T-MODULE Record Format -- SEGDEF.ACBP.C

The following table gives the meaning of the C field of the ACBP field:
ÚÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³C³                             Description                            ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³0³The LSEG is private and may not be combined.                        ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³1³Undefined.                                                          ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³2³The LSEG is public and may be combined with other LSEGs of the same ³
³ ³name.                                                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³3³Undefined.                                                          ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³4³The LSEG is public and may be combined with other LSEGs of the same ³
³ ³name.                                                               ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³5³The LSEG is a stack segment and may be combined with other LSEGs of ³
³ ³the same name.                                                      ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³6³The LSEG is a common segment and must be combined with other LSEGs  ³
³ ³of the same name.                                                   ³
ÃÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³7³The LSEG is public and may be combined with other LSEGs of the same ³
³ ³name.                                                               ³
ÀÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


               T-MODULE Record Format -- Notes on Combining

LSEGs which can be combined and are not common are combined as follows:

                      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                      ³LSEG data for first T-MODULE     ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³Alignment Gap for second T-MODULE³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³LSEG data for second T-MODULE    ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³            ///                  ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³Alignment Gap for last T-MODULE  ³
                      ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                      ³LSEG data for last T-MODULE      ³
                      ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

The resultant PSEG is the combined length of the above.

For common LSEGs, the length of the PSEG is the length of the largest
LSEG.  Therefore, the length of the PSEG cannot be determined until all
the T-MODULEs are processed.  For this reason, data cannot be loaded
into common segments until fixup time.


               T-MODULE Record Format -- LSEG Definition (SEGDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³ Segment ³Segment³Segment³Class³Overlay³Check³
           ³90H³Length³Attribute³Length ³ INDEX ³INDEX³ INDEX ³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³  1-4    ³  2    ³ INDEX ³INDEX³ INDEX ³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Segment Length --
  If ACBP.B is 0, then this is the length of the LSEG.  If ACBP.B is 1,
  then the Segment Length must be 0 and the length of the LSEG is
  65536 bytes.

Segment INDEX --
  This is an INDEX into the LNAME list.  LNAME[Segment INDEX] is the
  name of the LSEG.

Class INDEX --
  This is an INDEX into the LNAME list.  LNAME[Class INDEX] is the name
  of the LSEG.

Overlay INDEX --
  This is an INDEX into the LNAME list.  LNAME[Class INDEX] is the name
  of the LSEG.


               T-MODULE Record Format -- Group Definition (GRPDEF)

                    ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                    ³   ³Record³Group NAME ³   ³LSEG ³Check³
                    ³9AH³Length³  INDEX    ³FFH³INDEX³ Sum ³
                    ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
                    ³ 1 ³  2   ³  INDEX    ³ 1 ³INDEX³  1  ³
                    ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄrepeatedÙ

Like the LNAME list and SEGDEF list, the GRPDEFs form a list (indexed
relative to 1) of groups.  The is one GRPDEF record for each group in
the T-MODULE.

Group NAME INDEX --
  LNAME[Group NAME INDEX] is the name of the group.

LSEG INDEX --
  This field is repeated once for each LSEG in the group.  The LSEG
  INDEX is the INDEX into the LSEG list which corresponds to the LSEG
  in the group.


              T-MODULE Record Format -- Public Definition (PUBDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³Group³Segment³FRAME ³Public³Public³Type ³Check³
           ³90H³Length³INDEX³ INDEX ³NUMBER³ NAME ³Offset³INDEX³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³INDEX³ INDEX ³ 0-2  ³ NAME ³  2   ³INDEX³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄÄÄÄÄrepeatedÄÄÄÄÄÄÙ
Group INDEX --
  If the public(s) are defined is an LSEG which is part of a group,
  then this is the index into the group list.

Segment INDEX --
  If the public(s) are defined in an LSEG, this is the index into the
  LSEG list.

FRAME NUMBER --
  This field is only present if the public(s) are absolute (indicated
  by both Group INDEX and Segment INDEX being zero).  When present,
  this is the FRAME NUMBER used to reference the public(s).


              T-MODULE Record Format -- Public Definition (PUBDEF)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³Group³Segment³FRAME ³Public³Public³Type ³Check³
           ³90H³Length³INDEX³ INDEX ³NUMBER³ NAME ³Offset³INDEX³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³INDEX³ INDEX ³ 0-2  ³ NAME ³  2   ³INDEX³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄÄÄÄÄrepeatedÄÄÄÄÄÄÙ
Public NAME --
  This is the name of the public.

Public Offset --
  This is the distance of the start of the public from the group, LSEG
  or FRAME.

Type INDEX --
  This is ignored.


              T-MODULE Record Format -- Public Definition (EXTDEF)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³External³Type ³Check³
                        ³BCH³Length³  NAME  ³INDEX³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³  NAME  ³INDEX³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄÄÄrepeatedÄÄÄÙ

Like the LNAMEs, SEGDEFs, and GRPDEFs, the EXTDEFs form a list (indexed
relative to 1) of the external names used in this T-MODULE.

External NAME --
  This is the name of the external public symbol.

Type INDEX --
  This is ignored.


           T-MODULE Record Format -- Logical Enumerated Data (LEDATA)
 
                   ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                   ³   ³Record³Segment³      ³        ³Check³
                   ³A0H³Length³ INDEX ³Offset³  Data  ³ Sum ³
                   ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                   ³ 1 ³  2   ³ INDEX ³  2   ³   1    ³  1  ³
                   ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                             ÀrepeatedÙ

Segment INDEX --
  This data is to be loaded into the LSEG corresponding to SEGDEF list
  entry SEGDEF[Segment INDEX].

Offset --
  This data is to be loaded starting at this offset in the LSEG.

Data --
  The byte(s) to be loaded.  No more than 1024 can be loaded by an
  LEDATA record.


            T-MODULE Record Format -- Logical Iterated Data (LIDATA)
 
                  ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                  ³   ³Record³Segment³      ³ Iterated ³Check³
                  ³A2H³Length³ INDEX ³Offset³Data Block³ Sum ³
                  ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                  ³ 1 ³  2   ³ INDEX ³  2   ³ variable ³  1  ³
                  ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                            ÀÄrepeatedÄÙ

Segment INDEX --
  This data is to be loaded into the LSEG corresponding to SEGDEF list
  entry SEGDEF[Segment INDEX].

Offset --
  This data is to be loaded starting at this offset in the LSEG.

Iterated Data Block --
  This is (recursively) defined later, but the total size cannot exceed
  1024 bytes.


            T-MODULE Record Format -- Logical Iterated Data (LIDATA)


Iterated Data Block:  ÚÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿
                      ³Repeat³Block³        ³
                      ³Count ³Count³ Content³
                      ÃÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄ´
                      ³  2   ³  2  ³variable³
                      ÀÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÙ

Repeat Count --
  If Block Count is zero then Content is interpreted as a string of
  bytes of length Repeat Count.  If Block Count is zero, then this is
  the number of times the Content field is repeated.

Block Count --
  If this is zero, then the Content field is interpreted as a string of
  bytes of length Repeat Count.  If this is non-zero, then the Content
  field contains a string of Block Count Iterated Data Blocks.

Content --
  This is either a string of bytes as described above or it is a string
  of Iterated Data Blocks.


                 T-MODULE Record Format -- Fixup Record (FIXUPP)

                           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                           ³   ³Record³ Thread ³Check³
                           ³9CH³Length³or Fixup³ Sum ³
                           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                           ³ 1 ³  2   ³variable³  1  ³
                           ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                      ÀrepeatedÙ

Thread or Fixup --
  This field can be either a Thread (high order bit is 0) or Fixup
  (high order bit is 1).  A Thread is a default TARGET or FRAME method.
  There are four TARGET threads and four FRAME threads.  Thread fields
  are used to store the default TARGET or FRAME method.  A Fixup type
  field specifies the five pieces of information (discussed earlier)
  necessary to perform a fixup.



                        T-MODULE Record Format -- Thread

Thread:  ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄ¿  Thread Data:  ÚÄÂÄÂÄÂÄÄÄÄÄÄÂÄÄÄÄÄ¿
         ³Thread³Thread ³                ³0³D³0³Method³Thred³
         ³ Data ³ INDEX ³                ÃÄÅÄÅÄÅÄÄÄÄÄÄÅÄÄÄÄÄ´
         ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄ´                ³1³1³1³  3   ³  2  ³
         ³  1   ³0-INDEX³                ÃÄÁÄÁÄÁÄÄÄÄÄÄÁÄÄÄÄÄ´
         ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÙ                ³       byte       ³
                                         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

D --
  If D is zero then a TARGET thread is being specified, otherwise a
  FRAME thread is being specified.

Method --
  This is the TARGET or FRAME method.  For TARGET threads, only the
  four primary methods are specified.  All seven FRAME methods can be
  specified.

Thred --
  This is the TARGET or FRAME thread number being specified.

Thread INDEX --
  This is not present when F4, F5 or F6 is being specified.  In all
  other cases, this is either a Segment, Group or External index
  depending on the Method.


                         T-MODULE Record Format -- Fixup

                    ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³LOCAT³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³     ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  2  ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

LOCAT:  ÚÄÂÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
        ³ ³    ³ ³LOCATION³LE/LIDATA³
        ³1³Mode³0³  Type  ³  Offset ³
        ÃÄÅÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
        ³1³ 1  ³1³   3    ³    10   ³
        ÃÄÁÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´
        ³low byte          high byte³ Note:  Low and high bytes
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ        are swapped.
         
Mode --
  If Mode is 0 then this is a self-relative fixup, otherwise it is a
  segment-relative fixup.  Self-relative fixups on LIDATA are not
  permitted.


                         T-MODULE Record Format -- Fixup

LOCAT:  ÚÄÂÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
        ³ ³    ³ ³LOCATION³LE/LIDATA³
        ³1³Mode³0³  Type  ³  Offset ³
        ÃÄÅÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
        ³1³ 1  ³1³   3    ³    10   ³
        ÃÄÁÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´
        ³low byte          high byte³
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

LOCATION Type:  ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                ³LOCATION³Type Description³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      0 ³     LOBYTE     ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      1 ³     OFFSET     ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      2 ³     BASE       ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      3 ³     POINTER    ³
                ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³      4 ³     HIBYTE     ³
                ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                         T-MODULE Record Format -- Fixup

LOCAT:  ÚÄÂÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
        ³ ³    ³ ³LOCATION³LE/LIDATA³
        ³1³Mode³0³  Type  ³  Offset ³
        ÃÄÅÄÄÄÄÅÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
        ³1³ 1  ³1³   3    ³    10   ³
        ÃÄÁÄÄÄÄÁÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´
        ³low byte          high byte³
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

LE/LIDATA Offset --
  This field is used to determine the LOCATION information for the
  fixup.  This offset is actually an offset into the last LEDATA or
  LIDATA record.  The LEDATA or LIDATA contains the base LSEG and
  offset information.  Note that for LIDATA records, each time the data
  at LE/LIDATA Offset is repeated, the fixup must occur.


                         T-MODULE Record Format -- Fixup

                    ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³LOCAT³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³     ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  2  ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

Fixup Methods:  ÚÄÂÄÄÄÄÄÂÄÂÄÂÄÄÄÄÄÄ¿
                ³F³FRAME³T³P³TARGET³ F --
                ÃÄÅÄÄÄÄÄÅÄÅÄÅÄÄÄÄÄÄ´  If F is 1 then FRAME is a thread,
                ³1³  3  ³1³1³  2   ³  else FRAME is the FRAME method.
                ÃÄÁÄÄÄÄÄÁÄÁÄÁÄÄÄÄÄÄ´
                ³      byte        ³ T --
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  If T is 1 then TARGET is a thread,
                                      else TARGET is the TARGET method.
FRAME --
  This is either the FRAME method (F=0) or a FRAME thread (F=1).
TARGET --
  This is either the TARGET method (T=0) or a TARGET thread (T=1).
P --
  If P=0 then the primary TARGET methods are used and the TARGET Offset
  field will be present.


                         T-MODULE Record Format -- Fixup

                    ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³LOCAT³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³     ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  2  ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

FRAME INDEX --
  Depending on the FRAME method, this is either a Segment, Group, or
  External INDEX.  This will be present only when a FRAME thread is not
  used (F=0).

TARGET INDEX --
  Depending on the TARGET method, this is either a Segment, Group, or
  External INDEX.  This will be present only when a TARGET thread is
  not used (T=0).

TARGET Offset --
  The TARGET is TARGET Offset bytes from the Segment, Group, or
  External given by TARGET INDEX.


                 T-MODULE Record Format -- T-MODULE End (MODEND)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³End ³ Start  ³Check³
                        ³8AH³Length³Type³Address ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³ 1  ³variable³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

End Type:                   Attribute:
       ÚÄÄÄÄÄÄÄÄÄÂÄÂÄ¿            ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       ³Attribute³0³1³            ³Attribute³Description               ³
       ÃÄÄÄÄÄÄÄÄÄÅÄÅÄ´            ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    2    ³5³1³            ³    0    ³Non-main, no Start Address³
       ÃÄÄÄÄÄÄÄÄÄÁÄÁÄ´            ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ³    byte     ³            ³    1    ³Non-main, Start Address   ³
       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ            ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                                  ³    2    ³Main, no Start Address    ³
                                  ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                                  ³    3    ³Main, Start Address       ³
                                  ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


                 T-MODULE Record Format -- T-MODULE End (MODEND)


    Start Address:  ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄ¿
                    ³ Fixup ³ FRAME ³TARGET ³TARGET³
                    ³Methods³ INDEX ³INDEX  ³Offset³
                    ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄ´
                    ³  1    ³0-INDEX³0-INDEX³ 0-2  ³
                    ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÙ

The above fields work exactly the same as they do in a FIXUPP record.
The start address is computed from the FRAME and TARGET specified
above.  The initial CS is the FRAME NUMBER of the FRAME, and the
initial IP is TARGET - FRAME.


                T-MODULE Record Format -- Comment Record (COMENT)

                      ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                      ³   ³Record³Comment³        ³Check³
                      ³88H³Length³ Type  ³Comment ³ Sum ³
                      ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                      ³ 1 ³  2   ³  2    ³variable³  1  ³
                      ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Comment Type:  ÚÄÄÄÄÄÂÄÄÄÄÂÄÂÄÄÄÄÄ¿
               ³Purge³List³0³Class³
               ÃÄÄÄÄÄÅÄÄÄÄÅÄÅÄÄÄÄÄ´
               ³  1  ³ 1  ³6³  8  ³
               ÃÄÄÄÄÄÁÄÄÄÄÁÄÁÄÄÄÄÄ´
               ³       word       ³
               ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Purge --
  COMENT record should not be deleted by utilities which can delete
  comments (Purge=1).

List --
  COMENT record should not be listed by utilities which can list
  comments (LIST=1).


                T-MODULE Record Format -- Comment Record (COMENT)

ÚÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Class³                          Description                           ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 129 ³Do not do a default library search.                             ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 157 ³Memory model information is in the Comment field.               ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 158 ³Use the "DOSSEG" ordering.                                      ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 159 ³Library name is in the Comment field.                           ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 161 ³Codeview (registered trademark of Microsoft) information is     ³
³     ³present.                                                        ³
ÃÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ 162 ³Pass 1 of linker can stop processing T-MODULE here.             ³
ÀÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


             T-MODULE Record Format -- Communal Definition (COMDEF)

            ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
            ³   ³      ³Symbol³Type ³Far or Near³ Communal ³Check³
            ³B0H³Length³ NAME ³INDEX³ Communal  ³   Size   ³ Sum ³
            ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
            ³ 1 ³  2   ³ NAME ³INDEX³     1     ³ variable ³  1  ³
            ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÙ

Symbol NAME --
  This is the name of the communal symbol.  It is placed in the list of
  external symbols just as if it were an EXTDEF record.  If a PUBDEF
  record with the same Symbol NAME is encountered, it overrides the
  COMDEF.

Type INDEX --
  This is ignored.

Far or Near Communal --
  Far communals have a 61H coded here.  Near communals have a 62H coded
  here.

The ultimate size of the communal is the largest communal.


             T-MODULE Record Format -- Communal Definition (COMDEF)

For near communals, Communal Size is:  ÚÄÄÄÄÄ¿
                                       ³SIZE ³
                                       ³VALUE³
                                       ÃÄÄÄÄÄ´
                                       ³VALUE³
                                       ÀÄÄÄÄÄÙ

For far communals, Communal Size is:   ÚÄÄÄÄÄÂÄÄÄÄÄ¿
                                       ³COUNT³SIZE ³
    The size of the communal is:       ³VALUE³VALUE³
                                       ÃÄÄÄÄÄÅÄÄÄÄÄ´
      COUNT VALUE * SIZE VALUE         ³VALUE³VALUE³
                                       ÀÄÄÄÄÄÁÄÄÄÄÄÙ

Near communals go in DGROUP.  Far communals go in HUGE_BSS and are
packed as compactly as possible into PSEGs of no more than 64K.


           T-MODULE Record Format -- Forward Reference Fixups (FORREF)

                 ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                 ³   ³      ³Segment³    ³      ³ Fixup  ³Check³
                 ³B2H³Length³ INDEX ³Size³Offset³ Data   ³ Sum ³
                 ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                 ³ 1 ³  2   ³ INDEX ³ 1  ³  2   ³variable³  1  ³
                 ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                         ÀÄÄÄrepeatedÄÄÄÄÙ

Segment INDEX --
  The Forward Reference Fixup is to be applied to the LSEG element
  whose index into the SEGDEF list is Segment INDEX.
Size --
  This specifies the size of the Fixup Data fields.  The Fixup Data
  fields are a byte when Size = 0, a word when Size = 1, or a DWORD
  when Size = 2.
Offset --
  This is the Offset into the LSEG specified by Segment Index where the
  fixup is applied.
Fixup Data --
  This value is added at the specified Offset.

Note:  The FORREF record may occur before the LE/LIDATA records which
       load data into the LSEG.  Therefore, FORREFs must be applied at
       fixup time.


          T-MODULE Record Format -- Local External Definition (MODEXT)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³External³Type ³Check³
                        ³B4H³Length³  NAME  ³INDEX³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³  NAME  ³INDEX³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄÄÄrepeatedÄÄÄÙ


The fields of the MODEXT record function just like the EXTDEF record
except that the external is local to this T-MODULE only.  The External
NAME is included in the list of externals.


           T-MODULE Record Format -- Local Public Definition (MODPUB)

           ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
           ³   ³Record³Group³Segment³FRAME ³Public³Public³Type ³Check³
           ³B6H³Length³INDEX³ INDEX ³NUMBER³ NAME ³Offset³INDEX³ Sum ³
           ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÅÄÄÄÄÄ´
           ³ 1 ³  2   ³INDEX³ INDEX ³ 0-2  ³ NAME ³  2   ³INDEX³  1  ³
           ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
                                           ÀÄÄÄÄÄrepeatedÄÄÄÄÄÄÙ

The fields of the MODPUB record function just like the PUBDEF record
except that the public symbol is local to this T-MODULE only.


                 T-MODULE Record Format -- Line Number (LINNUM)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³          ³Check³
                        ³94H³Length³   Data   ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    1     ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄrepeatedÄÙ

The LINNUM record is ignored by the linker.


               T-MODULE Record Format -- Type Definition (TYPDEF)

                        ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ¿
                        ³   ³Record³          ³Check³
                        ³8EH³Length³   Data   ³ Sum ³
                        ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄ´
                        ³ 1 ³  2   ³    1     ³  1  ³
                        ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÙ
                                   ÀÄrepeatedÄÙ

The TYPDEF record is ignored by the linker.


                     T-MODULE Record Format -- Record Order

Object modules are parsed via recursive descent as defined below:

   t_module::     THEADR seg_grp {component} modtail

   seg_grp::      {LNAMES | SEGDEF | EXTDEF} {TYPDEF | EXTDEF | GRPDEF}

   component::    data | debug_record

   data::         content_def | thread_def | COMDEF | TYPDEF | PUBDEF |
                  EXTDEF | FORREF | MODPUB | MODEXT

   debug_record:: LINNUM

   content_def::  data_record {FIXUPP}

   thread_def::   FIXUPP  (containing only thread fields)

   data_record::  LIDATA | LEDATA

   modtail::      MODEND


                         Primary Internal Data Structure

ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿             ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Segment #1 ÃÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 Contents ³
ÀÄÄÄÄÄÂÄÄÄÄÄÄÙ             ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      ³                         ³
      ³                         ^
      ³                    ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      ³                    ³ LSEG #2 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #2 Contents ³
      ³                    ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      ³                         ^
      ³                        ///
      ^
ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿             ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Segment #2 ÃÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #1 Contents ³
ÀÄÄÄÄÄÂÄÄÄÄÄÄÙ             ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      ³                         ³
      ³                         ^
      ³                    ÚÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      ^                    ³ LSEG #2 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ>³ LSEG #2 Contents ³
     ///                   ÀÄÄÄÄÂÄÄÄÄÙ              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                ^
                               ///



                              Temp File

The linker employs a temp file to save information which can only be
processed after all the T-MODULEs have been processed.  The information
which must be saved is:

                              Fixups
                              LE/LIDATA for common LSEGS
                              FORREF records

The temp file is deleted when processing is complete.


                               Library File Format

 library_file::  header_page {t_modules} trailer_page {directory_pages}

 header_page ::    ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄ¿
                   ³   ³Record³Directory³Directory³          ³ ³
                   ³F0H³Length³ Offset  ³ Pages   ³   Pad    ³0³
                   ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄ´
                   ³ 1 ³  2   ³   4     ³   2     ³    1     ³1³
                   ÀÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÙ
                                         (prime)  ÀÄrepeatedÄÙ

 t_modules ::    The t_modules are as described above except a pad is
                 added after the MODEND record to make the t_module
                 occupy a full page.  The page size is the header_page
                 Record Length + 3.

 trailer_page ::   ÚÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄ¿
                   ³   ³Record³          ³ ³
                   ³F1H³Length³   Pad    ³0³
                   ÃÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄ´
                   ³ 1 ³  2   ³    1     ³1³
                   ÀÄÄÄÁÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÙ
                              ÀÄrepeatedÄÙ


                     Library File Format -- Directory

  directory_pages ::  public_pointer_array {public_entry} pad

Notes:  A directory page is always 512 bytes.  A directory page can
        contain up to 37 public entries.

public_pointer_array --
  This is a 38 byte array which is used to point into the public_entry
  field.  To determine where public i is located in the directory page,
  take the ith byte of the public_pointer_array (relative 0) and
  multiple it by 2.  That byte will be the beginning of the
  public_entry for ith public in the directory.  The 38th entry is used
  to point to the beginning of the free space in directory page.

public_entry ::  ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿
                 ³ Public³Starting³
                 ³ NAME  ³  Page  ³
                 ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄ´
                 ³ NAME  ³   2    ³
                 ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÙ


                     Library File Format -- Finding a Public

The library directory employs a two-tiered hashing scheme to store
public names in its directory.  A detailed description of the algorithm
is given later, but for now the following general aspects of the
algoritm are useful.  To start the search, you need to know which
directory page to start searching, and if you don't find it in that
page, which directory page to search next.  Once in a directory page,
you have to know which entry to use to begin the search and which entry
to search next if it was not found.

We will call the four required values STARTING_PAGE, DELTA_PAGE,
STARTING_ENTRY, and DELTA_ENTRY.  The detail on how to compute these
values is give later.

Start with directory page STARTING_PAGE.  On that page, examine
public_entry STARTING_ENTRY.  There are three cases.  This could be the
public symbol you desire, in which case you are done.  The
public_pointer_array for this entry could be zero, in which case the
symbol is not in the library.  Or, this the public symbol at
STARTING_ENTRY could be some other public symbol.  In this case, add
DELTA_ENTRY (modulo 37) to the STARTING_ENTRY and examine that public
entry.  Since there are at most 37 entries in any directory page,
examine no more than 37 entries in any given page.  If you have tried
all entries on a page, proceed to the next page by adding DELTA_PAGE
(modulo Directory_Pages) to STARTING_PAGE and continue the process.
When you move to a new page, continue processing the public entries
where you left off.


To compute the STARTING_PAGE, DELTA_PAGE, STARTING_ENTRY, and
DELTA_ENTRY, view a NAME field as if it were an array of bytes
containing the public name:

                        ÚÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄ//ÄÂÄÄÄÄÄÄ¿
            NAMEÄÄÄÄÄÄÄ>³Length³byte³byte³byte³    ³ byte ³
                        ÃÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄ//ÄÅÄÄÄÄÄÄ´
                        ³  1   ³ 1  ³ 1  ³ 1  ³    ³  1   ³
                        ÃÄÄÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄÄÄÄÅÄ//ÄÅÄÄÄÄÄÄ´
            indexÄÄÄÄÄÄ>³  0   ³ 1  ³ 2  ³ 3  ³    ³Length³
                        ÀÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÁÄÄÄÄÁÄ//ÄÁÄÄÄÄÄÄÙ

Then, the following code define the values:
STARTING_PAGE, DELTA_PAGE, STARTING_ENTRY, DELTA_ENTRY := 0;
for i := 0 .. Length-1
 STARTING_PAGE := STARTING_PAGE+(NAME[i] or 20H) xor (<<STARTING_PAGE);
 DELTA_PAGE := DELTA_PAGE+(NAME[Length-i+1] or 20H) xor (<<DELTA_PAGE);
 STARTING_ENTRY:= STARTING_ENTRY+(NAME[Length-i+1] or 20H)
                                     xor (>>STARTING_ENTRY);
 DELTA_ENTRY := DELTA_ENTRY+(NAME[i] or 20H) xor (>>DELTA_ENTRY);
end for;
if DELTA_ENTRY = 0 then DELTA_ENTRY := 1;
if DELTA_PAGE = 0 then DELTA_PAGE := 1;
Note:  << is circular shift left twice and
       >> is circular shift right twice.
«